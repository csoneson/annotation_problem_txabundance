
R version 3.4.0 (2017-04-21) -- "You Stupid Darkness"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> args <- (commandArgs(trailingOnly = TRUE))
> for (i in 1:length(args)) {
+   eval(parse(text = args[[i]]))
+ }
> 
> print(gene)  ## gene of interest, or file listing collection of genes (one per row)
[1] "alpine/20151016.A-Cortex_RNA/subset_genes_to_run.txt"
> print(bam)  ## bam file
[1] "STAR/20151016.A-Cortex_RNA/20151016.A-Cortex_RNA_Aligned.sortedByCoord.out.bam"
> print(bigwig)  ## bigwig file for visualization
[1] "STARbigwig/20151016.A-Cortex_RNA_Aligned.sortedByCoord.out.bw"
> print(genemodels)  ## gene models etc (output of alpine_prepare_for_comparison.R)
[1] "alpine/20151016.A-Cortex_RNA/alpine_genemodels.rds"
> print(biasmodels)  ## bias model object (output of alpine_fitbiasmodel.R)
[1] "alpine/20151016.A-Cortex_RNA/alpine_fitbiasmodel.rds"
> print(ncores)  ## number of cores for parallel computations
[1] 25
> print(outdir)  ## output directory
[1] "alpine_out/20151016.A-Cortex_RNA"
> print(checkdir)  ## directory to write (empty) rds files (time stamps)
[1] "alpine_check/20151016.A-Cortex_RNA"
> 
> suppressPackageStartupMessages(library(dplyr))
> suppressPackageStartupMessages(library(alpine))
> suppressPackageStartupMessages(library(GenomicAlignments))
> suppressPackageStartupMessages(library(BSgenome.Hsapiens.NCBI.GRCh38))
> suppressPackageStartupMessages(library(ggplot2))
> suppressPackageStartupMessages(library(cowplot))
> suppressPackageStartupMessages(library(ggrepel))
> suppressPackageStartupMessages(library(parallel))
> suppressPackageStartupMessages(library(grid))
> suppressPackageStartupMessages(library(gridExtra))
> 
> source("Rscripts/plot_tracks.R")
> 
> ## Read gene models for Gviz plot (pregenerated from gtf to save time) and
> ## quantifications
> genemodels <- readRDS(genemodels)
> 
> ## Read bias model parameters and exon-by-transcript objects
> biasmodels <- readRDS(biasmodels)
> fitpar <- biasmodels$fitpar
> ebt0 <- biasmodels$ebt0
> txps <- biasmodels$txps
> 
> ## Estimate average fragment length
> avefraglength <- sum(fitpar$`1`$fraglen.density$x * fitpar$`1`$fraglen.density$y/
+                        sum(fitpar$`1`$fraglen.density$y))
> 
> ## Load bam file 
> bam.files <- bam
> names(bam.files) <- "1"
> 
> ## Determine which gene(s) to investigate
> if (file.exists(gene)) {
+   genes <- unlist(read.delim(gene, as.is = TRUE, header = FALSE))
+ } else {
+   genes <- gene
+ }
> 
> ## Investigate each gene
> mclapply(genes, function(currgene) {
+   ## Get transcripts for gene of interest
+   txlist <- names(subset(txps, gene_id == currgene))
+   names(txlist) <- txlist
+   
+   if (length(txlist) > 0) {
+     
+     ## Predict coverage for each transcript
+     pred.cov <- lapply(txlist, function(tx) {
+       message(tx)
+       ## Get transcript model
+       txmod <- ebt0[[tx]]
+       
+       pc <- tryCatch({
+         m <- predictCoverage(gene = txmod,
+                              bam.files = bam.files,
+                              fitpar = fitpar,
+                              genome = Hsapiens,
+                              model.names = "all")
+         ## Scale predicted coverage to agree with estimated counts
+         m$`1`$pred.cov$scaled <- list()
+         for (nm in unique(genemodels$quants$method)) {
+           m$`1`$pred.cov$scaled[[nm]] <- m$`1`$pred.cov$all/sum(m$`1`$pred.cov$all) * 
+             genemodels$quants$count[genemodels$quants$transcript == tx & 
+                                       genemodels$quants$method == nm] * avefraglength
+         }
+         m
+       }, error = function(e) NULL)
+       pc
+     })
+     
+     junctionlist <- lapply(txlist, function(tx) {
+       txmod <- sort(ebt0[[tx]])
+       junctions <- GenomicRanges::setdiff(range(txmod), txmod)
+       junctioncov <- list()
+       if (all(strand(txmod) == "+")) {
+         junctionpos <- cumsum(width(txmod))
+         junctionpos <- junctionpos[-length(junctionpos)]
+         for (nm in unique(genemodels$quants$method)) {
+           junctioncov[[nm]] <- as.numeric(pred.cov[[tx]]$"1"$pred.cov$scaled[[nm]])[junctionpos]
+         }
+       } else if (all(strand(txmod) == "-")) {
+         junctionpos <- cumsum(width(rev(txmod)))
+         junctionpos <- junctionpos[-length(junctionpos)]
+         for (nm in unique(genemodels$quants$method)) {
+           junctioncov[[nm]] <- rev(as.numeric(pred.cov[[tx]]$"1"$pred.cov$scaled[[nm]])[junctionpos])
+         }
+       } else {
+         stop("Unknown or mixed strand")
+       }
+       for (nm in unique(genemodels$quants$method)) {
+         mcols(junctions)[, nm] <- junctioncov[[nm]]
+       }
+       junctions
+     })
+     
+     replna <- function(x) {
+       x[is.na(x)] <- 0
+       x
+     }
+     
+     # covcols <- grep("_coverage", colnames(mcols(junctionlist[[1]])), value = TRUE)
+     jl <- do.call(rbind, lapply(junctionlist, function(w) {
+       as.data.frame(w) %>%
+         tidyr::gather(method, coverage, -seqnames, -start, -end, -width, -strand)
+       })) %>% 
+       dplyr::group_by(seqnames, start, end, width, strand, method) %>%
+       dplyr::summarize(coverage = sum(coverage, na.rm = TRUE)) %>%
+       dplyr::mutate(coverage = replna(coverage)) %>%
+       # dplyr::summarize_at(.vars = covcols, .funs = sum, na.rm = TRUE) %>%
+       # dplyr::summarize(coverage = sum(coverage, na.rm = TRUE)) %>% 
+       ungroup()
+       # dplyr::mutate_at(.vars = covcols, .funs = funs(replna))
+       # dplyr::mutate(coverage = replace(coverage, is.na(coverage), 0))
+     
+     jl0 <- jl %>% dplyr::select(seqnames, start, end, width, strand) %>%
+       dplyr::distinct() %>% dplyr::arrange(start) %>% 
+       dplyr::mutate(junctionid = paste0("J", seq_len(length(start))))
+     
+     jl <- dplyr::left_join(jl, genemodels$jcov) %>%
+       dplyr::mutate(uniqreads = replace(uniqreads, is.na(uniqreads), 0),
+                     mmreads = replace(mmreads, is.na(mmreads), 0)) %>%
+       dplyr::group_by(method) %>%
+       dplyr::mutate(scaledcoverage = coverage/sum(coverage, na.rm = TRUE) * 
+                       sum(uniqreads, na.rm = TRUE)) %>%
+       dplyr::mutate(score = round(sum(abs(uniqreads - scaledcoverage), na.rm = TRUE)/
+                                     sum(uniqreads, na.rm = TRUE), 2)) %>% 
+       dplyr::mutate(methodscore = paste0(method, " (", score, ")")) %>%
+       dplyr::left_join(jl0) %>% dplyr::ungroup() %>% 
+       dplyr::select(junctionid, everything())
+       # dplyr::select(-coverage) %>%
+       # tidyr::spread(method, scaledcoverage) %>% 
+       # dplyr::mutate_at(.vars = covcols, .funs = funs(./sum(., na.rm = TRUE) * sum(uniqreads, na.rm = TRUE))) %>%
+       # dplyr::mutate(scaledcoverage = coverage/sum(coverage, na.rm = TRUE) * sum(uniqreads, na.rm = TRUE)) %>%
+       # dplyr::mutate(tot_coverage = sum(coverage, na.rm = TRUE),
+       #               tot_reads = sum(uniqreads, na.rm = TRUE)) %>%
+       # dplyr::mutate(prop_pval = calc_prop_p(coverage, uniqreads, tot_coverage, tot_reads)) %>%
+       # dplyr::mutate(junctionid = paste0("J", seq_len(length(uniqreads)))) %>% 
+       # dplyr::mutate(difference = uniqreads - scaledcoverage) %>%
+       # dplyr::mutate(ranking = order(order(difference))) %>%
+       # dplyr::select(junctionid, everything())
+     
+     pdf(paste0(outdir, "/plots/", currgene, ".pdf"), width = 12, height = 10)
+     tryCatch({
+       plot_tracks(mygene = currgene, genemodels = genemodels$genemodels_exon, 
+                   genemodels2 = genemodels$genemodels_cds, 
+                   gtf_file = NULL, rnaseq_datafiles = structure(bigwig, names = "s1"), 
+                   rnaseq_condition = structure("g1", names = "s1"), show_chr = NULL, 
+                   min_coord = NULL, max_coord = NULL, 
+                   pdf_filename = NULL, pdf_width = 7, pdf_height = 7)
+     }, error = function(e) message(e))
+     
+     # methods <- names(genemodels$quants)
+     # names(methods) <- methods
+     # genescore <- lapply(methods, function(nm) {
+     #   round(sum(abs(jl$uniqreads - jl[, paste0(nm, "_coverage")]), na.rm = TRUE)/
+     #           sum(jl$uniqreads, na.rm = TRUE), 2)
+     # })    
+     # genescore <- round(sum(abs(jl$uniqreads - jl$scaledcoverage), 
+     #                        na.rm = TRUE)/sum(jl$uniqreads, na.rm = TRUE), 2)
+     
+     print(ggplot(jl, aes(x = scaledcoverage, y = uniqreads, label = junctionid)) + 
+             geom_point(size = 4) + geom_label_repel() +
+             facet_wrap(~ methodscore) + 
+             geom_abline(intercept = 0, slope = 1) + 
+             xlab("Scaled predicted coverage") + 
+             ylab("Number of uniquely mapped reads") + 
+             theme_bw())
+     # plots <- lapply(methods, function(nm) {
+     #   ggplot(jl, aes_string(x = paste0(nm, "_coverage"), y = "uniqreads", 
+     #                         label = "junctionid")) + 
+     #     geom_point(size = 4) + geom_label_repel() + 
+     #     geom_abline(intercept = 0, slope = 1) + 
+     #     ggtitle(paste0(nm, ", score = ", genescore[[nm]])) + 
+     #     xlab("Scaled predicted coverage") + ylab("Number of uniquely mapped reads")
+     # })
+     # print(plot_grid(plotlist = plots))
+ 
+     # print(ggplot(jl, aes(x = scaledcoverage, y = uniqreads, label = junctionid)) + 
+     #         geom_point(size = 4) + geom_label_repel() + 
+     #         geom_abline(intercept = 0, slope = 1) + 
+     #         ggtitle(paste0("score = ", genescore)) + 
+     #         xlab("Scaled predicted coverage") + ylab("Number of uniquely mapped reads"))
+     dev.off()
+     
+     write.table(jl %>% dplyr::select(-score, -coverage, -method) %>%
+                   tidyr::spread(methodscore, scaledcoverage),
+                 file = paste0(outdir, "/jcov/", currgene, "_jcov.txt"),
+                 quote = FALSE, sep = "\t", row.names = FALSE, col.names = TRUE)
+     
+     write.table(genemodels$quants %>% dplyr::filter(transcript %in% txlist) %>% 
+                   dplyr::select(transcript, method, TPM) %>%
+                   tidyr::spread(method, TPM),
+                 file = paste0(outdir, "/tpm/", currgene, "_tpm.txt"),
+                 quote = FALSE, sep = "\t", row.names = FALSE, col.names = TRUE)
+     
+     write.table(genemodels$quants %>% dplyr::filter(transcript %in% txlist) %>% 
+                   dplyr::select(transcript, method, count) %>%
+                   tidyr::spread(method, count),
+                 file = paste0(outdir, "/count/", currgene, "_count.txt"),
+                 quote = FALSE, sep = "\t", row.names = FALSE, col.names = TRUE)
+     
+     # grid.newpage()
+     # quants0 <- genemodels$quants
+     # for (nm in names(quants0)) {
+     #   idx <- which(colnames(quants0[[nm]]) != "transcript")
+     #   colnames(quants0[[nm]])[idx] <- paste0(nm, "_", colnames(quants0[[nm]])[idx])
+     # }
+     # quants0 <- lapply(quants0, function(x) x %>% dplyr::filter(transcript %in% txlist))
+     # quants0 <- Reduce(function(...) dplyr::full_join(..., by = "transcript"), quants0)
+     # grid.table(quants0 %>% dplyr::select(-StringTie_EffectiveLength))
+     # grid.table(genemodels$quantsf %>% dplyr::filter(Name %in% txlist))
+     
+     # grid.newpage()
+     # grid.table(jl %>% dplyr::select(junctionid, seqnames, start, end, width, strand, 
+     #                                 uniqreads, mmreads, Salmon_coverage, kallisto_coverage,
+     #                                 RSEM_coverage, StringTie_coverage))
+     # 
+     # write.table(jl %>%
+     #               dplyr::mutate_at(.vars = covcols, .funs = funs(round(., 2))),
+     #             file = paste0(outdir, "/", currgene, ".txt"),
+     #             quote = FALSE, row.names = FALSE, col.names = TRUE, sep = "\t")
+     # print(as.data.frame(jl))
+     
+     saveRDS(jl, paste0(checkdir, "/", currgene, ".rds"))
+   }
+ }, mc.preschedule = FALSE, mc.cores = ncores)
ENST00000007516
ENST00000374399
ENST00000279022
ENST00000360156
ENST00000562133
ENST00000484769
ENST00000003912
ENST00000570319
ENST00000346786
ENST00000354228
ENST00000567761
Joining, by = c("seqnames", "start", "end", "strand")
Joining, by = c("seqnames", "start", "end", "width", "strand")
Joining, by = c("seqnames", "start", "end", "strand")
Joining, by = c("seqnames", "start", "end", "width", "strand")
ENST00000460411
ENST00000489216
ENST00000488155
ENST00000354416
ENST00000358028
ENST00000339255
ENST00000394610
ENST00000475663
ENST00000432012
Joining, by = c("seqnames", "start", "end", "strand")
Joining, by = c("seqnames", "start", "end", "width", "strand")
ENST00000343984
ENST00000467310
ENST00000481072
Joining, by = c("seqnames", "start", "end", "strand")
Joining, by = c("seqnames", "start", "end", "width", "strand")
$V11
NULL

$V12
NULL

$V13
NULL

$V14
NULL

> 
> saveRDS(NULL, paste0(checkdir, "/", basename(gene), ".rds"))
> sessionInfo()
R version 3.4.0 (2017-04-21)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Ubuntu 14.04.5 LTS

Matrix products: default
BLAS: /usr/local/R/R-3.4.0/lib/libRblas.so
LAPACK: /usr/local/R/R-3.4.0/lib/libRlapack.so

locale:
 [1] LC_CTYPE=en_CA.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_CA.UTF-8        LC_COLLATE=en_CA.UTF-8    
 [5] LC_MONETARY=en_CA.UTF-8    LC_MESSAGES=en_CA.UTF-8   
 [7] LC_PAPER=en_CA.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_CA.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
 [1] grid      stats4    parallel  stats     graphics  grDevices utils    
 [8] datasets  methods   base     

other attached packages:
 [1] Gviz_1.20.0                           
 [2] gridExtra_2.3                         
 [3] ggrepel_0.7.0                         
 [4] cowplot_0.8.0                         
 [5] ggplot2_2.2.1                         
 [6] BSgenome.Hsapiens.NCBI.GRCh38_1.3.1000
 [7] BSgenome_1.44.2                       
 [8] rtracklayer_1.36.4                    
 [9] GenomicAlignments_1.12.2              
[10] Rsamtools_1.28.0                      
[11] Biostrings_2.44.2                     
[12] XVector_0.16.0                        
[13] SummarizedExperiment_1.6.5            
[14] DelayedArray_0.2.7                    
[15] matrixStats_0.52.2                    
[16] Biobase_2.36.2                        
[17] GenomicRanges_1.28.5                  
[18] GenomeInfoDb_1.12.2                   
[19] IRanges_2.10.3                        
[20] S4Vectors_0.14.5                      
[21] BiocGenerics_0.22.0                   
[22] alpine_1.2.0                          
[23] dplyr_0.7.4                           

loaded via a namespace (and not attached):
 [1] ProtGenerics_1.8.0            bitops_1.0-6                 
 [3] bit64_0.9-7                   RColorBrewer_1.1-2           
 [5] httr_1.3.1                    tools_3.4.0                  
 [7] backports_1.1.1               R6_2.2.2                     
 [9] rpart_4.1-11                  Hmisc_4.0-3                  
[11] DBI_0.7                       lazyeval_0.2.0               
[13] colorspace_1.3-2              nnet_7.3-12                  
[15] curl_2.8.1                    bit_1.1-12                   
[17] compiler_3.4.0                graph_1.54.0                 
[19] htmlTable_1.9                 scales_0.5.0                 
[21] checkmate_1.8.4               RBGL_1.52.0                  
[23] speedglm_0.3-2                stringr_1.2.0                
[25] digest_0.6.12                 foreign_0.8-69               
[27] base64enc_0.1-3               dichromat_2.0-0              
[29] pkgconfig_2.0.1               htmltools_0.3.6              
[31] ensembldb_2.0.4               htmlwidgets_0.9              
[33] rlang_0.1.2                   RSQLite_2.0                  
[35] BiocInstaller_1.26.1          shiny_1.0.5                  
[37] bindr_0.1                     BiocParallel_1.10.1          
[39] acepack_1.4.1                 VariantAnnotation_1.22.3     
[41] RCurl_1.95-4.8                magrittr_1.5                 
[43] GenomeInfoDbData_0.99.0       Formula_1.2-2                
[45] Matrix_1.2-11                 Rcpp_0.12.13                 
[47] munsell_0.4.3                 stringi_1.1.5                
[49] yaml_2.1.14                   MASS_7.3-47                  
[51] zlibbioc_1.22.0               plyr_1.8.4                   
[53] AnnotationHub_2.8.2           blob_1.1.0                   
[55] lattice_0.20-35               splines_3.4.0                
[57] GenomicFeatures_1.28.5        knitr_1.17                   
[59] biomaRt_2.32.1                XML_3.98-1.9                 
[61] glue_1.1.1                    biovizBase_1.24.0            
[63] latticeExtra_0.6-28           data.table_1.10.4            
[65] httpuv_1.3.5                  gtable_0.2.0                 
[67] assertthat_0.2.0              mime_0.5                     
[69] xtable_1.8-2                  AnnotationFilter_1.0.0       
[71] survival_2.41-3               tibble_1.3.4                 
[73] AnnotationDbi_1.38.2          memoise_1.1.0                
[75] bindrcpp_0.2                  cluster_2.0.6                
[77] interactiveDisplayBase_1.14.0
> date()
[1] "Sun Nov 12 17:25:04 2017"
> 
> 
> proc.time()
   user  system elapsed 
237.513  12.483 201.394 
