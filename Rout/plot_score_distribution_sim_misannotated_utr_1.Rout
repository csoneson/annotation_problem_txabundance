
R Under development (unstable) (2017-12-14 r73916) -- "Unsuffered Consequences"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ################################################################################
> ##                                                                            ##
> ## Plot overall distribution of gene-wise scores, as well as the association  ##
> ## with various gene characteristics                                          ##
> ##                                                                            ##
> ## Inputs:                                                                    ##
> ## * scorerds: list containing abundance estimates and characteristics for    ##
> ##             junctions, transcripts and genes, as well as gene scores.      ##
> ##             Generated by calculate_gene_scores.R                           ##
> ## * quantmethods: string containing the quantification methods to consider,  ##
> ##                 separated by commas (no spaces)                            ##
> ## * uniqjuncreadsthresholds: string giving the threshold(s) on the number    ##
> ##                            of uniquely mapping junction spanning reads     ##
> ##                            that will be used to filter the set of genes,   ##
> ##                            separated by commas (no spaces)                 ##
> ## * outrds: output rds file. The name will be used to determine the name of  ##
> ##           the output figures.                                              ##
> ##                                                                            ##
> ## Outputs:                                                                   ##
> ## * A png figure illustrating the number of genes with valid scores, as well ##
> ##   as the reason for missing scores                                         ##
> ## * One png figure for each unique junction reads threshold, showing the     ##
> ##   overall distribution of scores for the included genes, as well as the    ##
> ##   association between the score and various gene characteristics           ##
> ##                                                                            ##
> ################################################################################
> 
> args <- (commandArgs(trailingOnly = TRUE))
> for (i in 1:length(args)) {
+   eval(parse(text = args[[i]]))
+ }
> 
> quantmethods <- strsplit(quantmethods, ",")[[1]]
> uniqjuncreadsthresholds <- as.numeric(strsplit(uniqjuncreadsthresholds, ",")[[1]])
> 
> print(scorerds)
[1] "output/sim_misannotated_utr_1_combined_coverages_with_scores.rds"
> print(quantmethods)
[1] "hera"          "kallisto"      "RSEM"          "Salmon"       
[5] "SalmonSTAR"    "SalmonCDS"     "SalmonKeepDup" "StringTie"    
> print(uniqjuncreadsthresholds)
[1]  0 25
> print(outrds)
[1] "figures/gene_scores/gene_scores_sim_misannotated_utr_1.rds"
> 
> suppressPackageStartupMessages({
+   library(dplyr)
+   library(ggplot2)
+   library(cowplot)
+ })
> 
> ## Load method colors
> source("Rscripts/define_plot_colors.R")
> 
> ## Read scores
> scores <- readRDS(scorerds)$genes
> 
> ## Keep only methods of interest
> scores <- scores %>% dplyr::filter(method %in% quantmethods)
> 
> ## Count genes with a valid score, and characterize those without
> scoresNA <- scores %>% 
+   dplyr::group_by(method) %>% 
+   dplyr::summarize(
+     valid_score = sum(!is.na(score)),
+     not_expressed = sum(is.na(score) & count == 0),
+     no_junctions = sum(is.na(score) & count > 0 & nbr_junctions_in_gene == 0, 
+                        na.rm = TRUE),
+     junctions_but_no_unique_reads = sum(is.na(score) & count > 0 & 
+                                           nbr_junctions_in_gene > 0 & 
+                                           uniqjuncreads == 0, na.rm = TRUE),
+     junctions_but_too_few_unique_reads = sum(is.na(score) & count > 0 & 
+                                                nbr_junctions_in_gene > 0 & 
+                                                uniqjuncreads > 0 & 
+                                                uniqjuncfraction <= 0.75, na.rm = TRUE),
+     other = length(score) - valid_score - not_expressed - no_junctions - 
+       junctions_but_no_unique_reads - junctions_but_too_few_unique_reads) %>% 
+   tidyr::gather(reason, number, -method) %>% 
+   dplyr::mutate(reason = replace(reason, reason == "valid_score", "Valid JCC score"),
+                 reason = replace(reason, reason == "not_expressed", "Estimated abundance = 0"),
+                 reason = replace(reason, reason == "no_junctions", "No junctions"),
+                 reason = replace(reason, reason == "junctions_but_no_unique_reads", 
+                                  "Has junctions, but no uniquely mapping junction reads"),
+                 reason = replace(reason, reason == "junctions_but_too_few_unique_reads",
+                                  "Has junctions, but too large fraction multimapping junction reads"),
+                 reason = replace(reason, reason == "other", "Other")) %>%
+   dplyr::mutate(reason = factor(
+     reason, levels = c("Has junctions, but too large fraction multimapping junction reads",
+                        "Has junctions, but no uniquely mapping junction reads",
+                        "No junctions",
+                        "Other", "Estimated abundance = 0", "Valid JCC score")))
> 
> png(gsub("\\.rds$", "_NAscores.png", outrds), width = 8, height = 6, 
+     unit = "in", res = 300)
> print(ggplot(scoresNA, aes(x = method, y = number, fill = reason)) + 
+         geom_bar(stat = "identity") + theme_bw() + 
+         theme(legend.position = "bottom") + 
+         guides(fill = guide_legend(nrow = 2, title = "")) + 
+         scale_fill_manual(
+           values = c(`Valid JCC score` = "#000099",
+                      `Estimated abundance = 0` = "#9999ff",
+                      `Other` = "#b30059",
+                      `No junctions` = "#99e600",
+                      `Has junctions, but no uniquely mapping junction reads` = "#cc3300",
+                      `Has junctions, but too large fraction multimapping junction reads` = "#ffb399")
+         ) + 
+         xlab("") + ylab("Number of genes"))
> dev.off()
null device 
          1 
> 
> ## For each threshold on the number of uniquely mapping junction reads, plot the
> ## distribution of scores and the association with gene characteristics
> subplots <- list()
> for (mincount in uniqjuncreadsthresholds) {
+   png(gsub("\\.rds$", paste0("_min", mincount, "uniqjuncreads.png"), outrds), width = 14, 
+       height = 16, unit = "in", res = 300)
+   
+   ## Plot score distribution
+   ## Overall distribution
+   g1 <- ggplot(scores %>% dplyr::filter(!is.na(score) & uniqjuncreads >= mincount), 
+                aes(x = 1, y = score, fill = method)) + 
+     geom_violin() + theme_bw() + facet_wrap(~ method, nrow = 1, scales = "free_x") + 
+     scale_fill_manual(values = method_colors) + ylab("JCC score") + 
+     theme(legend.position = "none",
+           axis.text.x = element_blank(), 
+           axis.ticks.x = element_blank()) + xlab("")
+   
+   ## Scores vs fraction of unique junction reads
+   g2 <- ggplot(scores %>% dplyr::filter(!is.na(score) & uniqjuncreads >= mincount),
+                aes(x = uniqjuncfraction, y = score, color = method)) +
+     geom_point(alpha = 0.5, size = 0.5) + theme_bw() + ylab("JCC score") + 
+     facet_wrap(~ method, nrow = 1, scales = "free_x") +
+     geom_smooth(color = "black", method = "loess") + 
+     xlab("Fraction uniquely mapping junction reads") +
+     theme(legend.position = "none") + 
+     scale_color_manual(values = method_colors)
+       
+   ## Scores vs maximum 3'UTR length
+   if ("max_3putr_length" %in% colnames(scores)) {
+     g3 <- ggplot(scores %>% dplyr::filter(!is.na(score) & uniqjuncreads >= mincount),
+                  aes(x = max_3putr_length, y = score, color = method)) +
+       geom_point(alpha = 0.5, size = 0.5) + theme_bw() + ylab("JCC score") + 
+       facet_wrap(~ method, nrow = 1, scales = "free_x") +
+       geom_smooth(color = "black", method = "loess") + xlab("Maximal 3'UTR length") +
+       theme(legend.position = "none") + 
+       scale_color_manual(values = method_colors)
+   } else {
+     g3 <- NULL
+   }
+       
+   ## Scores vs fraction of transcripts with valid (i.e. not imposed uniform)
+   ## coverage prediction
+   g4 <- ggplot(scores %>% dplyr::filter(!is.na(score) & uniqjuncreads >= mincount),
+                aes(x = covOKfraction, y = score, color = method)) +
+     geom_point(alpha = 0.5, size = 0.5) + theme_bw() + ylab("JCC score") + 
+     facet_wrap(~ method, nrow = 1, scales = "free_x") +
+     geom_smooth(color = "black", method = "loess") + 
+     xlab("Fraction of transcripts with non-uniform predicted coverage") +
+     theme(legend.position = "none") + 
+     scale_color_manual(values = method_colors)
+       
+   ## Scores vs number of uniquely mapping junction reads
+   g5 <- ggplot(scores %>% dplyr::filter(!is.na(score) & uniqjuncreads >= mincount),
+                aes(x = uniqjuncreads, y = score, color = method)) +
+     geom_point(alpha = 0.5, size = 0.5) + theme_bw() + ylab("JCC score") + 
+     facet_wrap(~ method, nrow = 1, scales = "free_x") +
+     geom_smooth(color = "black", method = "loess") + 
+     xlab("Number of uniquely \nmapped junction reads") +
+     theme(legend.position = "none") + scale_x_sqrt() + 
+     scale_color_manual(values = method_colors)
+       
+   ## Scores vs maximum transcript length
+   g6 <- ggplot(scores %>% dplyr::filter(!is.na(score) & uniqjuncreads >= mincount),
+                aes(x = max_transcript_length, y = score, color = method)) +
+     geom_point(alpha = 0.5, size = 0.5) + theme_bw() + ylab("JCC score") + 
+     facet_wrap(~ method, nrow = 1, scales = "free_x") +
+     geom_smooth(color = "black", method = "loess") + 
+     xlab("Maximal transcript length") + theme(legend.position = "none") + 
+     scale_color_manual(values = method_colors)
+       
+   ## Scores vs intron/exon count ratio
+   if ("intron_exon_ratio" %in% colnames(scores)) {
+     g7 <- ggplot(scores %>% dplyr::filter(!is.na(score) & uniqjuncreads >= mincount) %>% 
+                    dplyr::mutate(intron_exon_ratio = replace(intron_exon_ratio, 
+                                                              intron_exon_ratio > 10, 10)), 
+                  aes(x = intron_exon_ratio, y = score, color = method)) + 
+       geom_point(alpha = 0.5, size = 0.5) + theme_bw() + ylab("JCC score") + 
+       facet_wrap(~ method, nrow = 1, scales = "free_x") + 
+       geom_smooth(color = "black", method = "loess") + 
+       xlab("Intron/exon count ratio") + theme(legend.position = "none") + 
+       scale_color_manual(values = method_colors)
+   } else {
+     g7 <- NULL
+   }
+       
+   ## Scores vs total gene count
+   g8 <- ggplot(scores %>% dplyr::filter(!is.na(score) & uniqjuncreads >= mincount),
+                aes(x = count, y = score, color = method)) + 
+     geom_point(alpha = 0.5, size = 0.5) + theme_bw() + 
+     facet_wrap(~ method, nrow = 1, scales = "free_x") + ylab("JCC score") + 
+     geom_smooth(color = "black", method = "loess") + 
+     xlab("Gene count") + scale_x_sqrt() + theme(legend.position = "none") + 
+     scale_color_manual(values = method_colors)
+     
+   ## Scores vs number of transcripts
+   g9 <- ggplot(scores %>% dplyr::filter(!is.na(score) & uniqjuncreads >= mincount) %>%
+                  dplyr::mutate(nbr_transcripts = replace(nbr_transcripts,
+                                                          nbr_transcripts > 60, 60)), 
+                aes(x = nbr_transcripts, y = score, color = method)) + 
+     geom_point(alpha = 0.5, size = 0.5) + theme_bw() + ylab("JCC score") + 
+     facet_wrap(~ method, nrow = 1, scales = "free_x") + 
+     geom_smooth(color = "black", method = "loess") + 
+     xlab("Number of transcripts") + theme(legend.position = "none") + 
+     scale_color_manual(values = method_colors)
+       
+   ## Scores vs number of junctions in gene
+   g10 <- ggplot(scores %>% dplyr::filter(!is.na(score) & uniqjuncreads >= mincount) %>%
+                   dplyr::mutate(nbr_junctions_in_gene = replace(nbr_junctions_in_gene,
+                                                                 nbr_junctions_in_gene > 700, 700)),
+                 aes(x = nbr_junctions_in_gene, y = score, color = method)) + 
+     geom_point(alpha = 0.5, size = 0.5) + theme_bw() + ylab("JCC score") + 
+     facet_wrap(~ method, nrow = 1, scales = "free_x") + 
+     geom_smooth(color = "black", method = "loess") + 
+     xlab("Number of junctions") + theme(legend.position = "none") + 
+     scale_color_manual(values = method_colors)
+       
+   ## Scores vs length difference between 3'UTRs starting in the same place
+   if ("length_diff_3putrs_samestart" %in% colnames(scores)) {
+     g11 <- ggplot(scores %>% dplyr::filter(!is.na(score) & uniqjuncreads >= mincount),
+                   aes(x = length_diff_3putrs_samestart, y = score, color = method)) + 
+       geom_point(alpha = 0.5, size = 0.5) + theme_bw() + ylab("JCC score") + 
+       facet_wrap(~ method, nrow = 1, scales = "free_x") + 
+       geom_smooth(color = "black", method = "loess") + 
+       xlab("Length difference of 3'UTRs with same start") + 
+       theme(legend.position = "none") + 
+       scale_color_manual(values = method_colors)
+   } else {
+     g11 <- NULL
+   }
+    
+   print(
+     cowplot::plot_grid(
+       g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11, ncol = 1
+     )
+   )   
+   dev.off()
+   
+   subplots[[paste0("_min", mincount, "uniqjuncreads")]] <- 
+     cowplot::plot_grid(g1 + facet_wrap(~ method, ncol = 1), 
+                        g8 + facet_wrap(~ method, ncol = 1), 
+                        g5 + facet_wrap(~ method, ncol = 1), 
+                        nrow = 1, align = "h", axis = "tb")
+ }
