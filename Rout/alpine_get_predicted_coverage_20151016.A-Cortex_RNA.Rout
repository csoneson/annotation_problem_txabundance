
R Under development (unstable) (2017-12-14 r73916) -- "Unsuffered Consequences"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> args <- (commandArgs(trailingOnly = TRUE))
> for (i in 1:length(args)) {
+   eval(parse(text = args[[i]]))
+ }
> 
> print(bam)  ## bam file
[1] "STAR/20151016.A-Cortex_RNA/20151016.A-Cortex_RNA_Aligned.sortedByCoord.out.bam"
> print(biasmodels)  ## bias model object (output of alpine_fitbiasmodel.R)
[1] "alpine/20151016.A-Cortex_RNA/alpine_fitbiasmodel.rds"
> print(ncores)  ## number of cores for parallel computations
[1] 25
> print(outrds)  ## output file
[1] "alpine/20151016.A-Cortex_RNA/alpine_predicted_coverage.rds"
> 
> suppressPackageStartupMessages({
+   library(alpine)
+   library(GenomicAlignments)
+   library(BSgenome.Hsapiens.NCBI.GRCh38)
+   library(parallel)
+ })
> 
> ## Read bias model parameters and exon-by-transcript objects
> biasmodels <- readRDS(biasmodels)
> fitpar <- biasmodels$fitpar
> ebt0 <- biasmodels$ebt0
> 
> ## Estimate average fragment length
> avefraglength <- sum(fitpar$`1`$fraglen.density$x * fitpar$`1`$fraglen.density$y/
+                        sum(fitpar$`1`$fraglen.density$y))
> 
> ## Load bam file 
> bam.files <- bam
> names(bam.files) <- "1"
> 
> ## Get all transcripts
> transcripts <- names(ebt0)
> names(transcripts) <- transcripts
> 
> res <- mclapply(transcripts, function(tx) {
+   message(tx)
+   ## Get transcript model
+   txmod <- ebt0[[tx]]
+   txmods <- sort(ebt0[[tx]])
+   
+   ## Predict coverage
+   m <- tryCatch({
+     a <- predictCoverage(gene = txmod,
+                          bam.files = bam.files,
+                          fitpar = fitpar,
+                          genome = Hsapiens,
+                          model.names = "all")
+     if (!is.null(a$`1`$pred.cov$all)) {
+       list(covr = a$`1`$pred.cov$all,
+            note = "covOK")
+     } else {
+       ## E.g. if there are no reads mapping to the gene locus
+       ## Assume uniform coverage
+       list(covr = Rle(rep(1, sum(width(txmod)) - 1)),
+            note = "covNA")
+     }
+   }, 
+   error = function(e) {
+     print(paste(c(tx, e), collapse = ": "))
+     ## E.g. if the transcript is shorter than the fragment length
+     ## Assume uniform coverage
+     list(covr = Rle(rep(1, sum(width(txmod)) - 1)),
+          note = "covError")
+   })
+   
+   note <- m$note
+   m <- m$covr
+   
+   ## Get predicted coverage for junctions
+   junctions <- GenomicRanges::setdiff(range(txmods), txmods)
+   if (all(strand(txmods) == "+")) {
+     junctionpos <- cumsum(width(txmods))
+     junctionpos <- junctionpos[-length(junctionpos)]
+     mcols(junctions)$pred.cov <- as.numeric(m)[junctionpos]
+     strand <- "+"
+   } else if (all(strand(txmods) == "-")) {
+     junctionpos <- cumsum(width(rev(txmods)))
+     junctionpos <- junctionpos[-length(junctionpos)]
+     mcols(junctions)$pred.cov <- rev(as.numeric(m)[junctionpos])
+     strand <- "-"
+   } else {
+     strand <- "mixed"
+   }
+   
+   list(pred.cov = m, strand = strand, junctions = junctions, 
+        avefraglength = avefraglength, note = note)
+   
+ }, mc.preschedule = FALSE, mc.cores = ncores)
ENST00000000233
ENST00000000412
ENST00000000442
ENST00000001008
ENST00000001146
ENST00000002125
ENST00000002165
ENST00000002501
ENST00000002596
ENST00000002829
ENST00000003084
ENST00000003100
ENST00000003302
ENST00000003583
ENST00000003912
ENST00000004103
ENST00000004531
ENST00000004982
ENST00000005082
ENST00000005178
ENST00000005180
ENST00000005226
ENST00000005257
ENST00000005259
ENST00000005260
ENST00000005284
ENST00000005286
ENST00000005340
ENST00000005374
ENST00000005386
ENST00000005558
ENST00000005756
ENST00000005995
ENST00000006015
ENST00000006053
ENST00000006251
ENST00000006275
ENST00000006658
ENST00000006724
ENST00000006750
ENST00000006777
ENST00000007264
ENST00000007390
ENST00000007414
ENST00000007510
ENST00000007516
ENST00000007699
ENST00000007708
ENST00000007722
ENST00000007735
ENST00000007969
ENST00000008180
ENST00000008391
ENST00000008440
ENST00000008527
ENST00000008876
ENST00000008938
ENST00000009041
ENST00000009105
ENST00000009180
ENST00000009530
ENST00000009589
ENST00000010132
ENST00000010299
ENST00000010404
ENST00000011292
ENST00000011473
ENST00000011619
ENST00000011653
ENST00000011684
ENST00000011691
ENST00000011700
ENST00000011898
ENST00000011989
ENST00000012049
ENST00000012134
ENST00000012443
ENST00000013034
ENST00000013070
ENST00000013125
ENST00000013222
ENST00000013807
ENST00000013894
ENST00000014914
ENST00000014930
ENST00000014935
ENST00000016171
ENST00000016913
ENST00000016946
ENST00000017003
ENST00000019019
ENST00000019103
ENST00000019317
ENST00000020673
ENST00000020926
ENST00000020945
ENST00000022615
ENST00000023064
ENST00000023897
ENST00000023939
ENST00000024061
ENST00000025008
ENST00000025301
ENST00000025399
